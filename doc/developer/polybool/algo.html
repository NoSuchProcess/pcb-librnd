<html>
<body>
<center>
<H1> A CLOSED SET OF ALGORITHMS FOR PERFORMING SET OPERATIONS ON POLYGONAL REGIONS IN THE PLANE... </H1>
<h2> ... for coders </h2>
</center>
<h3> Preface to this interpretation </h3>
<dl>
<p>
<a href="https://web.archive.org/web/20160418014630/http://www.complex-a5.ru/polyboolean/downloads/polybool_eng.pdf">
The excellent paper</a>by <i>Michael V. Leonov and Alexey G. Nikitin</i> at the
<i>A. P. Ershov Institute of Information Systems, Siberian Branch of Russian</i>
back from the 1990s clearly and precisely presents a surprisingly simple
algorithm for the problem also called <i>polygon clipping</i>. Besides describing
the algorithm, the paper also gives accurate definitions and an estimation on
runtime.
<p>
While the paper, in its original form, is already rather useful, I've found
that as a coder, I have hard time processing some parts of it, because
of the following factors:
<ul>
	<li> mathematically precise, but often complex wording for expressing otherwise simple concepts
	<li> condensed mathematical expressions
	<li> file format: the original pdf seems to be broken (I had two different pdf reader implementation choke on it)
	<li> while figures and example cases are chosen very wisely to present interesting cases, labeling and coloring could make it easier to understand them
</ul>
<p>
This document is an English-to-English translation of the original paper, with
the intended target audience being coders who want to undertsand and implement
the algorith but do not wish to prove or verify the maths begind it.
In fact, this document is more of <i>my personal interpretation</i>
than a translation.
<p>
This document closely follows the structure of the original document, so
that the two can be read in parallel.
<p>
I heavily simplified or even skipped parts that are very important for
mathematical correctness but not required for implementing the algorithm in
code. Instead of the mathematical notations,  beyond the real
basic operators I use named operator function; instead of single letter
variables, I use multiple-letter ASCII-only variable names (no greek letters).
Instead of condensing the formulas, I rather make them more verbose, explaining
what each variable is for. These modifications may degrade pedantic mathematical
correctness, but I believe it makes it easier to digest the information on
first pass.
<p>
I've also redrawn all illustrations so they have more labels, more colors;
more information explicitly encoded in them that otherwise could have been
implied or figured from context.
<p>
Finally, this document is plain, hand written html, which is much more portable
than pdf.
</dl>


<h3> Abstract </h3>
<p>
See the original paper.

<h3> Introduction </h3>
<p>
See the original paper.

<h3> Basic definitions </h3>
<p>
(Definition 1 and 2)
<p>
A [polygon]<i>region</i> consists of zero or more <i>islands</i>.
(The original paper calls this <i>polygon</i>; this document will call it
island to reduce confusion with similar terms.)
An island is an outer polyline and zero or more inner polylines (which act
as cutouts). A <i>polyline</i> is an ordererd, cyclic list of x;y vertices
on the 2D plane, containing at least 3 vertices.
<p>
An <i>edge</i> is a straight line segment<sup><a href="#note1">1</a></sup>
that starts from such a vertex and ends at the next vertex; an edge is
referenced by its starting vertex. This also means edges are directed from
start vertex to end vertex. There are no zero-legth edges.
<p>
Given such a directed edge, there is a left neighborhood and a right neighborhood
(of imaginary points) next to the edge. (This concept is used only to decide
if something is left or right to the edge.)
<p>
The <i>straight</i> ordering of vertices or edges within a polyline is
counter-clockwise (CCW), the <i>reverse</i> ordering is CW.
<p>
TODO: figure 2 (extended)
<p>
A <i>high degree</i> vertex is shared by the endpoints of more than edges.
<p>
(Definition 3)
<p>
Give a polyline, there's an <i>inner neighborhood</i> (all points inside
the polyline) and an <i>outer neighborhood</i> (all points outside).
A valid polyline can be self touching (a vertex between
two edges falling ona 3rd edge of the polyline) but can not be self
intersecting.
<p>
The outline of an island is always <i>straight</i> (CCW) while cutouts
are always <i>reversed</i> (CW). Each island has exactly one outline, and that is
the outmost polyline of the island. Polylines of an island do not touch or
intersect other polylines within the island.
<p>
TODO: figure 3 (colored)
<p>
Naming convention: this document will name vertices as V or Vsomething,
edges as E or Esomthing, and index them starting from 0 from an
arbitrarily chosen vertex on the polyline, so that (for example) Efoo[5]
is the edge that starts at Vfoo[0] and ends at Vfoo[1]. The last edge of
a polyline of n vertices, E[n-1] is between V[n-1] and V[0]. Polylines
are named Psomething; when indexed, Pfoo[0] is the outline, indices starting
from 1 refer to cutouts.

<h3> The algorithm </h3>
<p>
Input:
<ul>
	<li> A and B: two regions
	<li> op: an operation (one of: <i>union</i>, <i>intersection</i>, <i>difference</i>, <i>xor</i><sup><a href="#note1">2</a></sup>)
</ul>
Output: a region R; R = op(A, B).
<p>
The algorihm is split up in four steps:
<ul>
	<li> Step 1. Processing of the edge intersections.
	<li> Step 2. Edge and contour labeling.
	<li> Step 3. Collecting the resulting contours.
	<li> Step 4. Placing the resulting contours in R.
</ul>

<p>
TODO: figure 4 (colored)


<h3> Step 1: processing edge intersections </h3>
<p>
Find all intersections between edge objects of A and B (ignoring the
shared endpoint of adjacent edges within a polyline but not ignoring
other intersections happening between edges of the same polyline):
<ul>
	<li> for an edge-edge mid intersection, insert a new vertex in both regions, at the intersection point, splitting edge both objects
	<li> if a vertex of an island is on the edge of another, split that edge inserting a new vertex in the intersection point
	<li> if two edges overlap, split them ensuring there's a vertex on the start and end of the overlap
	<li> (if two vertices fall on the same point, don't do anything)
</ul>
<p>
By now any intersection has an explicit vertex on all related polylines.
If there are multiple vertices falling on the same point, that means there is
an intersection/touching there and all vertices on that point are called <i>
cross-verticles</i>.
<p>
Comment: for each such point of intersection there are at least two
cross-verticles for such a point.
<p>
Comment: this process <b>does change the structure of input regions</b>, when it is creating new vertices,
which means if the original regions are to be preserved, a copy needs to be made.
However, this process (<b>in theory</b><sup><a href="#note3">3</a>, <a href="#note4">4</a></sup>)
does not change the shape/meaning/topology of the input regions.)
<p>
Take each cross-vertex V[i], where i is the index of the given vertex within
the polyline. There will be a <i>previous edge</i> Ep that
ends on that vertex and a <i>next edge</i> En that starts at that vertex.
Allocate two <i>cross-vertex descriptors</i> (CVD), Dp and Dn, and assign them
to Ep and En respectively (cross-linking the corresponding E and D with pointers
in both directions). A CVD contains angle<sup><a href="#note5">5</a></sup> information and flags.
<p>
For every intersection point, collecd all CVDs into a cyclic list called
the <i>connectivity list [of that point]</i>. The connectivity list is ordered
by the angle of the CVDs (fig. 6). Order of equal angles is unspecified.
<p>
TODO: figure 6
<p>
TODO: the paragraph under figure 6 on page 8.


<h3> Step 2. Edge and contour labeling </h3>
<p>
Let Pc be the outer contour of either input region A or input region B. Let Pm
be the outer contour of the other input region.
<p>
(Predicate 1.) After the first step:
<ul>
	<li> Any par of edges of A and B intersect at their endpoints (and
	     may or may not overlap, but if they overlap, they overlap in full
	     length)
	<li> Every edge of Pc:
		<ul>
			<li> either overlaps with an edge in Pm (and is called a <i>shared edge</i>)
			<li> or lies fully inside Pm (except for an endpoint maybe)
			<li> or lies fully outside Pm (except for an endpoint maybe)
		</ul>
	<li> if Pc does not have any cross-vertex, it is either fully inside Pm or
	     is outside of Pm
</ul>
<p>
The label on an edge E of Pc is one of:
<ul>
	<li> INSIDE: when E is inside Pm
	<li> OUTSIDE: when E is outside Pm
	<li> SHARED1: when E overlaps with an edge from Pm that, and the two edges have the same direction
	<li> SHARED2: when E overlaps with an edge from Pm that, and the two edges have different direction
</ul>
<p>
The label of Pc is one of:
<ul>
	<li> ISECTED: if it contains at least one cross-vertex
	<li> INSIDE: if it has no cross-vertex and it is fully inside Pm
	<li> OUTSIDE: if it has no cross-vertex and is outside of Pm
</ul>

<h4>Algorithm for edge (and polyline) labeling</h4>
<ul>
	<li> 1. If Pc does not contain any cross-vertice: label Pc INSIDE or OUTSIDE<sup><a href="#note6">6</a></sup>. Do not label edges of Pc.
	<li> 2. If Pc contains at least one cross-vertex: label Pc ISECTED, and label
	     its each edge E[i] (i is between 0 and n, n is the number of vertices in Pc):
	<ul>
		<li> 2.1. if E does not contain cross-vertices at its endpoints:
			<ul>
				<li> 2.1.2. if i == 0: if starting vertex lies inside Pm label E[i] INSIDE, else label E[i] OUTSIDE
				<li> 2.1.1. if i != 0: copy label value from E[i-1]
			</ul>
		<li> 2.2. if E contains 1 or 2 cross-vertices at its endpoints:
			<ul>
				<li> 2.2.1. there is an overlapping edge in Pm that has the same starting point as E and the same ending point as E: label E as SHARED1
				<li> 2.2.2. there is an overlapping edge in Pm that has the same starting point as the endpoint of E and the same ending point as the start point of E: label E as SHARED2
				<li> 2.2.3. Pc's cross-vertices connectivity lists do not contain any vertex from Pm: C touches itself but doesn't intersect M; jump to 2.1
				<li> 2.2.4. Pc's cross-vertices connectivity lists contains vertices (called Vm[j]) from Pm:
					<ul>
						<li> take the <i>sector<i> defined by Vm[j-1], Vm[j] and Vm[j+1]
						<li> check, using the angle of E: if E is inside that <i>sector</i>, label E as INSIDE, else label E as OUTSIDE (see Fig. 7).
					</ul>
			</ul>
	</ul>
</ul>
<p>
TODO: Fig. 7

<h3> Step 3. Collecting the resulting contours </h3>
<p>
An essential idea is that the polylines of R are collected using edge and
polyline labels instead of using coordinates<sup><a href="#note7">7</a></sup>.



<h3> Notes </h3>
<p>
These notes are not in the original paper, but are collected by the author
of this document on the basis of interpretation of the original paper and
experience with an implementation of this algorithm in pcb-rnd.

<p id="note1">1. While the original paper deals with lines only,
I belive the algorithm would work with any non-self-intersecting curve
object in place of a straight line segment. Some parts of the algorithm
depends on having at least 3 vertices in a valid polyline. This assumption
could be violated by using non-linear objects. For example with circular arcs
it's easily possible to have a 2-object "polyline", or even a single-object
one (a full circle). These corner cases can easily be avoided by splitting up
such, at arbitrary points, into 2 or 3 edges.

<p id="note2">2. The xor operation is called "symmetrical difference" in
the original paper.

<p id="note3">3. In practice it does, due to finite precision/resolution of
number representation in the common programming practices. If vertex
coordinates are integers, intersection of two sloped edges will rarely fall
onto integer coordinates. Inserting a new vertex at the nearest integer coords
will slightly change the input region because instead of a single straight line
at a specific slope, the result is two slightly differently sloped lines. Using
floating point numbers instead of integers does not solve the problem either,
because there are finite numbers that can be represented, so the intersection
will likely fall in between two such numbers and the same rounding has to be done,
and the same type of error is introduced.

<p id="note4">4. The error introduced in note 3 can be significant: sligtly
changing the slope of (a section of) an edge that had a touching vertex
from another island can convert that touching into a full intersection or
no touching, and this does change the topology of the problem.

<p id="note5">5. This does not have to be a real angle; anything that yields
the same ordering for a set of edges at a cross-vertex's point as if the
edges were ordered by true angle will work the same. A suitable cheaper
metric is the 0..1 normalized slope of the edge (e.g. dx/dy) combined
with the quadrant in which the edge falls, so that the result is between 0..4.

<p id="note6">6. It is enough to determine if one random vertex of Pc is
inside or outside, the rest of the vertices must be the same, because
no cross vertex means no intersection between Pc and Pm.

<p id="note7">7. This means the algorithm is <i>topological</i>: in step 1 it deals
with coordinates to determine intersections and it inserts new vertices
at them. After that step the whole algorithm is only about linearly iterating
over lists and sometimes deciding where to go at intersections, but all these
are done purely on the topological infromation (<i>order</i> of points, CVDs, 
left-of/right-of, previous-of/next-of, inside/outside concepts).


