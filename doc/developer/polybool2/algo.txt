Binary boolean operation between multi-island polygons A and B specified by contour
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Def: input polygons are A and B for binary ops and A for unary ops
Def: canon: an unary operator on a single input polygon that resolves the
     self intersections and irregularities of that polygon
Def: segment is a line or an arc
Def: curve is an ordered list of segments with no intersection
Def: face: a closed loop of curves (represented by an ordered list of
     curve IDs), without any curve crossing it; may embed other faces but
     the curves of those faces may not touch the curves of the outer face
Def: output tree [of faces]: a tree of faces; each node is a face with
     child nodes that are smaller faces fully within

1. switch to topology
	1.1. compute intersections of any two segments (using both A and B)
	1.2. split segments at intersections
	1.3. collect segments into curves between intersections
	1.4. handle overlaps
		1.4.1. map curves that are fully overlapping; their endpoints must match
		1.4.2. take a group of all overlapping curves for a single pair of endpoints
		       and remove all but one curve
(		1.4.2. take a group of all overlapping curves for a single pair of endpoints
			- if there is at least one other curve ends on both endpoints:
				- if there are even number of curves in the group, remove all curves
				- otherwise remove all curves from this group except one
			- else this is a stub: remove all curves of this group
)

2. map faces
	- Algo: https://cp-algorithms.com/geometry/planar.html
	- Note: overlapping lines, e.g. in a bone, O--O case may result in
	        having a curve that's not part of any face; ignore such curves
	- Note: for curves of faces, each curve should have a list of
	        faces that use the curve (this is at most two faces per curve)
	- Note: calculate the approximate area of each face to throw away the outer
	        one that overlaps all

3. mark input polarity: for each face
	3.1. choose an internal point of the face
	3.2. face->inA := 1 or 0 depending on if the point is inside input polygon A
	3.3. face->inB := 1 or 0 depending on if the point is inside input polygon B
	3.4. compute polarity of faces: for each face compute face->out from
       face->inA and face->inB, depending on the operator, as:
		- A union B:     out = inA or inB
		- A sub B:       out = inA and not inB
		- A intersect B: out = inA and inB
		- A xor B:       out = inA xor inB
		- canon A:       out = inA

4. figure which curves to keep: for each curve:
	- if the curve has two adjacent faces, mark the curve "pruned" if the
	  ->out of those two faces are equal
	- if the curve has only one adjacent face, mark the curve "pruned" if
	  face's ->out is 0 (not filled)

5. gather curves into output faces:
	Re-run step 2 but ignore curves marked "pruned". This step can be skipped if
	there was no pruning in step 4 (and the face list from step 2 can be used as
	output faces).

	The result is an unordered "list of output faces".

6. stack output faces, building the output tree of faces:
	6.0. create an output tree with the root node being an infinitely large
	     negative face
	6.1. take the largest remaining output face "off the list of output faces"
	6.2. iterate over the existing tree to see whether the output face is
	     within any of the leaves
		- if yes: insert the output face as a child face of that leaf face,
		  with polarity being the inverse of the leaf face
		- if not: the output face is a new root in the output tree with
		  positive polarity
	6.3. go back to 7.1. if "list of output faces" is not empty

	The result is the output tree.

	(This is to figure the polarity of each output face)

7. flatten the tree:
	Iterate over each face in the output tree; for positive faces create
	a polygon island; for negative faces create a polygon hole within the
	island previously created for the parent face.

8. cleanup
	8.1. optional: visit each output contour and look at each interesected 
	     vertex; if the two segments on the two sides can be converted into
	     a single segment (e.g. coaxial lines or arcs on the same circle), merge
	     them to reduce the number of vertices
	8.2. discard and free the output tree (created in 7.)
	8.3. discard and free the list of output face (created in 6., should be empty by now)
	8.4. free all curves and faces used
