Binary boolean operation between multi-island polygons A and B specified by contour
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Def: input polygons are A and B for binary ops and A for unary ops
Def: canon: an unary operator on a single input polygon that resolves the
     self intersections and irregularities of that polygon
Def: segment is a line or an arc
Def: curve is an ordered list of segments with no intersection
Def: face: a closed loop of curves (represented by an ordered list of
     curve IDs)
Def: clean face: a face that has no curve crossing its perimeter curves
Def: output tree [of faces]: a tree of faces; each node is a face with
     child nodes that are smaller faces fully within

1. switch to topology
	1.1. compute intersections of any two segments (using both A and B)
	1.2. split segments at intersections
	1.3. collect segments into curves between intersections
	1.4. handle overlaps
		1.4.1. map curves that are fully overlapping; their endpoints must match
		1.4.2. take a group of all overlapping curves for a single pair of endpoints
		       and remove all but one curve
(		1.4.2. take a group of all overlapping curves for a single pair of endpoints
			- if there is at least one other curve ends on both endpoints:
				- if there are even number of curves in the group, remove all curves
				- otherwise remove all curves from this group except one
			- else this is a stub: remove all curves of this group
)

2. map faces
	2.1. map all possible faces;
	     Algo: https://cp-algorithms.com/geometry/planar.html
	     Note: overlapping lines, e.g. in a bone, O--O case may result in
	     having a curve that's not part of any face; ignore such curves
	2.2. for curves of faces, each curve should have a list of
	     faces that use the curve (this is at most two faces per curve)

3. mark input polarity: for each face
	3.1. choose an internal point of the face
	3.2. face->inA := 1 or 0 depending on if the point is inside input polygon A
	3.3. face->inB := 1 or 0 depending on if the point is inisde input polygon B

4. compute polarity of faces: for each face compute face->out from
   face->inA and face->inB, depending on the operator, as:
		- A union B:     out = inA or inB
		- A sub B:       out = inA and not inB
		- A intersect B: out = inA and inB
		- A xor B:       out = inA xor inB
		- canon A:       out = inA

5. figure which curves to keep: for each curve:
	- if the curve has two adjacent faces, keep the curve the ->out of those
	  two faces are not equal
	- if the curve has only one adjacent face, keep the curve if the
	  face's ->out is 1
	Discarded curves are removed and freed.

6. gather curves into output faces:
	6.1. take a the leftmost/topmost curve and put it on an output curve list
	     list, and mark the curve visited
	6.2. check the adjacent curves on the other endpoint:
		- if any of the curves is already marked visited, we have a closed face;
		  convert the output curve list into an output face, clear the output face
		  and start over at 6.1.
		- ignore any curves that are already marked visited
		- pick one of the remaining curves, append it to the outpt curve list
		  and jump back to 6.2

	The result is an unordered "list of output faces".

7. stack output faces, building the output tree of faces:
	7.0. create an output tree with the root node being an infinitely large
	     negative face
	7.1. take the largest remaining output face "off the list of output faces"
	7.2. iterate over the existing tree to see whether the output face is
	     within any of the leaves
		- if yes: insert the output face as a child face of that leaf face,
		  with polarity being the inverse of the leaf face
		- if not: the output face is a new root in the output tree with
		  positive polarity
	7.3. go back to 7.1. if "list of output faces" is not empty

	The result is the output tree.

	(This is to figure the polarity of each output face)

8. flatten the tree:
	Iterate over each face in the output tree; for positive faces create
	a polygon island; for negative faces create a polygon hole within the
	island previously created for the parent face.

9. cleanup
	9.1. optional: visit each output contour and look at each interesected 
	     vertex; if the two segments on the two sides can be converted into
	     a single segment (e.g. coaxial lines or arcs on the same circle), merge
	     them to reduce the number of vertices
	9.2. discard and free the output tree (created in 7.)
	9.3. discard and free the list of output face (created in 6., should be empty by now)
	9.4. free all curves and faces used
